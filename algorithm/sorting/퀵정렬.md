# 퀵정렬이란?

퀵 정렬(QuickSort)은 **분할 정복(Divide and Conquer) 방식**을 이용하여 데이터를 정렬하는 효율적인 알고리즘입니다. 1959년 **Tony Hoare**에 의해 개발된 이 알고리즘은 평균적으로 **O(n log n)**의 시간 복잡도를 가지며, 실전 환경에서 뛰어난 성능을 발휘합니다. 특히, **불균형한 분할을 방지하는 전략**을 적절히 활용하면 안정적인 성능을 유지할 수 있습니다.

## 퀵 정렬의 동작 원리

퀵 정렬은 이 과정이 반복되면서 배열이 정렬됩니다.

**피벗(Pivot) 선택 :** 정렬할 배열에서 특정한 요소를 피벗으로 선택합니다. 피벗을 선택하는 방식에 따라 성능이 달라질 수 있습니다.

**분할(Partitioning) :** 피벗을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽에 배치합니다. 이 과정을 거치면 피벗의 최종 위치가 결정됩니다.

**재귀 호출(Recursive Call) :** 피벗을 제외한 왼쪽과 오른쪽 부분 배열에 대해 동일한 퀵 정렬을 수행합니다.

## 퀵 정렬이 적합한 경우

퀵 정렬은 평균적으로 빠른 정렬 속도를 가지므로, 다음과 같은 경우에 유용합니다.

- **배열의 크기가 클 때**: O(n log n)의 성능을 유지하기 때문에 효율적입니다.
- **메모리 사용을 최소화해야 할 때**: 추가적인 공간을 거의 사용하지 않는 **제자리 정렬(in-place sorting)** 방식이므로, 추가적인 메모리 할당이 적습니다.
- **데이터가 무작위로 분포되어 있을 때**: 데이터가 균등하게 분포되어 있다면 빠른 성능을 발휘합니다.

그러나 퀵 정렬은 최악의 경우 **O(n²)**의 시간 복잡도를 가질 수 있습니다. 따라서 **이미 정렬된 배열이나 중복된 값이 많은 데이터**의 경우, 적절한 피벗 선택 전략을 활용하는 것이 중요합니다.

## 퀵 정렬의 시간 복잡도

퀵 정렬의 성능은 피벗 선택 방식과 입력 데이터의 분포에 따라 달라집니다.

- **평균 시간 복잡도**: O(n log n)
  - 피벗이 균등하게 배열을 나누는 경우, 대부분의 상황에서 효율적입니다.
- **최악의 시간 복잡도**: O(n²)
  - 이미 정렬된 배열에서 최솟값이나 최댓값을 피벗으로 선택하는 경우, 한쪽에만 요소가 몰려 재귀 호출이 O(n)번 발생하는 상황입니다.
- **최선의 시간 복잡도**: O(n log n)
  - 피벗이 항상 배열을 절반씩 나누는 경우입니다.

이처럼 퀵 정렬은 **적절한 피벗 선택 전략**을 활용하면 대부분의 경우 효율적인 정렬을 수행할 수 있습니다.

## 효율적인 피벗 선택 방법

퀵 정렬에서 피벗(Pivot) 선택 전략은 매우 중요합니다. 적절하지 않은 피벗 선택은 **O(n²)**의 성능 저하를 초래할 수 있으므로, 효과적인 선택 방법을 살펴보겠습니다.

### 1. 첫 번째 요소를 피벗으로 선택

- **장점**: 구현이 간단합니다.
- **단점**: 이미 정렬된 배열에서는 최악의 성능(O(n²))이 발생할 수 있습니다.
- **사용 예시**: 데이터가 무작위로 배치된 경우에만 적절합니다.

### 2. 마지막 요소를 피벗으로 선택

- **장점**: 간단하지만 첫 번째 요소를 선택하는 방식과 차이가 크지 않습니다.
- **단점**: 이미 정렬된 데이터에서 최악의 성능을 보일 가능성이 높습니다.

### 3. 중앙 요소를 피벗으로 선택

- **장점**: 첫 번째 또는 마지막 요소를 선택하는 방식보다 안정적인 성능을 보입니다.
- **단점**: 데이터가 불균형하게 분포될 경우 성능 저하가 발생할 수 있습니다.

### 4. 랜덤 피벗 선택 (Randomized Pivot)

- **장점**: 최악의 경우를 방지할 확률이 높습니다.
- **단점**: 랜덤 값을 선택하는 연산이 추가됩니다.

### 5. **Median of Three (세 값의 중간값 선택)**

- **방법**: 첫 번째, 중간, 마지막 요소 중 중간값을 피벗으로 선택합니다.
- **장점**: 이미 정렬된 배열에서도 좋은 성능을 유지할 수 있습니다.
- **단점**: 약간의 추가 연산이 필요하지만, 최악의 경우를 효과적으로 방지할 수 있어 실전에서 많이 사용됩니다.

## 퀵 정렬 예제 (단계별 과정)

`[8, 3, 7, 4, 9, 2, 6, 5]` 배열을 `Median of Three` 방식을 활용하여 퀵 정렬을 수행해 보겠습니다.

### 1단계: 첫 번째 분할 (피벗: 5)

퀵 정렬의 첫 번째 단계로, 배열의 첫 번째 요소(8), 중앙 요소(4), 마지막 요소(5) 중에서 **중간값(5)** 을 피벗으로 선택합니다.

| 8(멈춤) | 3 | 7 | 4 | 9 | 2 | 6 (이동) | 5 (pivot) |
| --- | --- | --- | --- | --- | --- | --- | --- |
| low → |  |  |  |  |  | ← high |  |
- `8`은 피벗보다 크므로 교환이 필요하기 때문에 멈춥니다. `6`은 피벗보다 크므로 high 포인터를 이동합니다.

| 8(멈춤) | 3 | 7 | 4 | 9 | 2(멈춤) | 6 | 5 (pivot) |
| --- | --- | --- | --- | --- | --- | --- | --- |
| low → |  |  |  |  | ← high |  |  |
- `2`가 피벗보다 작으므로 교환이 필요합니다.

| 2(8과 교환) | 3 | 7 | 4 | 9 | 8(2와 교환) | 6 | 5 (pivot) |
| --- | --- | --- | --- | --- | --- | --- | --- |
|  | low → |  |  | ← high |  |  |  |
- `8`과 `2`를 교환하고, 교환했으므로 low, high 포인터를 이동합니다.

| 2 | 3 | 7(멈춤) | 4 | 9 | 8 | 6 | 5 (pivot) |
| --- | --- | --- | --- | --- | --- | --- | --- |
|  |  | low → | ← high |  |  |  |  |
- `7`이 피벗보다 크므로 멈추고 9는 피봇보다 크므로 high 포인터를 이동합니다.

| 2 | 3 | 4 (7과 교환) | 7(4와 교환) | 9 | 8 | 6 | 5 (pivot) |
| --- | --- | --- | --- | --- | --- | --- | --- |
|  |  | ← high | low → |  |  |  |  |
- `4`와 `7`을 교환하고, 교환했으므로 low, high 포인터를 이동합니다.

| 2 | 3 | 4 | 5 (7과 교환) | 9 | 8 | 6 | 7 (5와 교환) |
| --- | --- | --- | --- | --- | --- | --- | --- |
|  |  | ← high | low →  |  |  |  |  |
- 더이상 low가 high보다 커졌으므로, 더이상 진행을 멈추고 pivot과 자리를 바꿉니다.

```
정렬 완료 (1단계 결과): [2, 3, 4, 5, 9, 8, 6, 7]
```

---

### 2단계: 왼쪽 부분 (`[2, 3, 4]`) 정렬

| 2  | 4  | 3 (pivot) |
| --- | --- | --- |
| low → | ← high |  |
- 3이 중간값이므로 제일 오른쪽으로 이동시킵니다. low와 high 모두 pivot과 비교하여 맞는 위치에 있으므로 이동합니다.

| 2  | 3 (4와 교환) | 4 (3과 교환) |
| --- | --- | --- |
| ← high | low →  |  |
- low가 4에서 멈추고, high가 앞으로 진행합니다. low가 high보다 커졌으므로 low와 pivot의 위치를 바꿔줍니다.

```
정렬 완료 (2단계 결과): [2, 3, 4]
```

---

### 3단계: 오른쪽 부분 (`[9, 8, 6, 7]`) 정렬

| 9 (멈춤) | 7 (8과 교환) | 6 (멈춤) | 8 (7과 교환) |
| --- | --- | --- | --- |
| low → |  | ← high |  |
- 8이 중간값이므로 제일 오른쪽으로 이동시킵니다. pivot과 비교하여  9, 6 모두 위치가 잘못되었으므로 멈춥니다.

| 6 (9와 교환) | 7 | 9 (6과 교환) | 8 (pivot) |
| --- | --- | --- | --- |
|  | low → ← high |  |  |
- 6과 9를 교환하고, 교환했으므로 low, high 포인터를 이동합니다.

| 6 | 7 | 8 (9와 교환) | 9 (8과 교환) |
| --- | --- | --- | --- |
|  | ← high | low →  |  |
- 7은 pivot보다 작으므로 low를 이동시키고 멈춥니다. 그리고 low가 high보다 커졌으므로 멈추고 pivot과 위치를 교환합니다.

```
정렬 완료 (3단계 결과): [6, 7, 8, 9]
```

---

### 4단계: 반복

`[2, 3, 4]`, `[6, 7, 8, 9]`  해당 배열들이 각각 배열길이가 1개 혹은 0개가 될때까지 위 정렬을 반복합니다. 그러면 아래와 같은 결과가 나옵니다.

```
[2, 3, 4, 5, 6, 7, 8, 9]

```

---

# 퀵정렬이란?

퀵 정렬(QuickSort)은 **분할 정복(Divide and Conquer) 방식**을 이용하여 데이터를 정렬하는 효율적인 알고리즘입니다. 1959년 **Tony Hoare**에 의해 개발된 이 알고리즘은 평균적으로 **O(n log n)**의 시간 복잡도를 가지며, 실전 환경에서 뛰어난 성능을 발휘합니다. 특히, **불균형한 분할을 방지하는 전략**을 적절히 활용하면 안정적인 성능을 유지할 수 있습니다.

## 퀵 정렬의 동작 원리

퀵 정렬은 이 과정이 반복되면서 배열이 정렬됩니다.

**피벗(Pivot) 선택 :** 정렬할 배열에서 특정한 요소를 피벗으로 선택합니다. 피벗을 선택하는 방식에 따라 성능이 달라질 수 있습니다.

**분할(Partitioning) :** 피벗을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽에 배치합니다. 이 과정을 거치면 피벗의 최종 위치가 결정됩니다.

**재귀 호출(Recursive Call) :** 피벗을 제외한 왼쪽과 오른쪽 부분 배열에 대해 동일한 퀵 정렬을 수행합니다.

## 퀵 정렬이 적합한 경우

퀵 정렬은 평균적으로 빠른 정렬 속도를 가지므로, 다음과 같은 경우에 유용합니다.

- **배열의 크기가 클 때**: O(n log n)의 성능을 유지하기 때문에 효율적입니다.
- **메모리 사용을 최소화해야 할 때**: 추가적인 공간을 거의 사용하지 않는 **제자리 정렬(in-place sorting)** 방식이므로, 추가적인 메모리 할당이 적습니다.
- **데이터가 무작위로 분포되어 있을 때**: 데이터가 균등하게 분포되어 있다면 빠른 성능을 발휘합니다.

그러나 퀵 정렬은 최악의 경우 **O(n²)**의 시간 복잡도를 가질 수 있습니다. 따라서 **이미 정렬된 배열이나 중복된 값이 많은 데이터**의 경우, 적절한 피벗 선택 전략을 활용하는 것이 중요합니다.

## 퀵 정렬의 시간 복잡도

퀵 정렬의 성능은 피벗 선택 방식과 입력 데이터의 분포에 따라 달라집니다.

- **평균 시간 복잡도**: O(n log n)
    - 피벗이 균등하게 배열을 나누는 경우, 대부분의 상황에서 효율적입니다.
- **최악의 시간 복잡도**: O(n²)
    - 이미 정렬된 배열에서 최솟값이나 최댓값을 피벗으로 선택하는 경우, 한쪽에만 요소가 몰려 재귀 호출이 O(n)번 발생하는 상황입니다.
- **최선의 시간 복잡도**: O(n log n)
    - 피벗이 항상 배열을 절반씩 나누는 경우입니다.

이처럼 퀵 정렬은 **적절한 피벗 선택 전략**을 활용하면 대부분의 경우 효율적인 정렬을 수행할 수 있습니다.

## 효율적인 피벗 선택 방법

퀵 정렬에서 피벗(Pivot) 선택 전략은 매우 중요합니다. 적절하지 않은 피벗 선택은 **O(n²)**의 성능 저하를 초래할 수 있으므로, 효과적인 선택 방법을 살펴보겠습니다.

### 1. 첫 번째 요소를 피벗으로 선택

- **장점**: 구현이 간단합니다.
- **단점**: 이미 정렬된 배열에서는 최악의 성능(O(n²))이 발생할 수 있습니다.
- **사용 예시**: 데이터가 무작위로 배치된 경우에만 적절합니다.

### 2. 마지막 요소를 피벗으로 선택

- **장점**: 간단하지만 첫 번째 요소를 선택하는 방식과 차이가 크지 않습니다.
- **단점**: 이미 정렬된 데이터에서 최악의 성능을 보일 가능성이 높습니다.

### 3. 중앙 요소를 피벗으로 선택

- **장점**: 첫 번째 또는 마지막 요소를 선택하는 방식보다 안정적인 성능을 보입니다.
- **단점**: 데이터가 불균형하게 분포될 경우 성능 저하가 발생할 수 있습니다.

### 4. 랜덤 피벗 선택 (Randomized Pivot)

- **장점**: 최악의 경우를 방지할 확률이 높습니다.
- **단점**: 랜덤 값을 선택하는 연산이 추가됩니다.

### 5. **Median of Three (세 값의 중간값 선택)**

- **방법**: 첫 번째, 중간, 마지막 요소 중 중간값을 피벗으로 선택합니다.
- **장점**: 이미 정렬된 배열에서도 좋은 성능을 유지할 수 있습니다.
- **단점**: 약간의 추가 연산이 필요하지만, 최악의 경우를 효과적으로 방지할 수 있어 실전에서 많이 사용됩니다.

## 퀵 정렬 예제 (단계별 과정)

아래 배열을 `Median of Three` 방식을 활용하여 퀵 정렬을 수행해 보겠습니다.

### 단계별 정렬 과정(`[8, 3, 7, 4, 9, 2, 6, 5]`)

### 1단계: 첫 번째 분할 (피벗: 5)

| 단계 | 배열 상태 | 비교 요소 | 이동 방향 |
| --- | --- | --- | --- |
| 초기 | 8, 3, 7, 4, 9, 2, 6, 5 | 8, 4, 5 중 가운데 값 5 선택  | - |
| 비교 | 8 ↔ 3 | 8 > 5 → 3이 왼쪽 이동 | 3, 8, 7, 4, 9, 2, 6, 5 |
| 비교 | 8 ↔ 7 | 8 > 5 → 7이 왼쪽 이동 | 3, 7, 8, 4, 9, 2, 6, 5 |
| 비교 | 8 ↔ 4 | 8 > 5 → 4가 왼쪽 이동 | 3, 7, 4, 8, 9, 2, 6, 5 |
| 비교 | 9 ↔ 2 | 9 > 5 → 2가 왼쪽 이동 | 3, 7, 4, 2, 8, 9, 6, 5 |
| 비교 | 8 ↔ 6 | 8 > 5 → 6이 왼쪽 이동 | 3, 7, 4, 2, 6, 9, 8, 5 |
| 피벗 정렬 후 | 3, 4, 2, 5, 9, 8, 6, 7 | 5과 7을 교환 | 5이 중간 위치로 이동 |

<aside>
💡

왜 피벗이 가운데로 이동하는가?

</aside>

<aside>
💡

피벗보다 큰 값을 왼쪽에서 찾고, 작은 값을 오른쪽에서 찾으며 교환합니다.

</aside>

<aside>
💡

이 과정을 반복하면서 피벗보다 작은 값들은 왼쪽으로, 큰 값들은 오른쪽으로 배치됩니다.

</aside>

<aside>
💡

마지막으로 피벗을 적절한 위치에 놓으면 왼쪽에는 작은 값, 오른쪽에는 큰 값이 배치되며, 피벗이 자연스럽게 중간으로 이동하게 됩니다.

</aside>

### 2단계: 왼쪽 부분 배열 정렬 (피벗: 3)

| 단계 | 배열 상태 | 비교 요소 | 이동 방향 |
| --- | --- | --- | --- |
| 초기 | 3, 4, 2 | - | - |
| 비교 | 4 ↔ 2 | 4 > 3 → 2가 왼쪽 이동 | 2, 4, 3 |
| 피벗 정렬 후 | 2, 3, 4 | - | - |

### 3단계: 오른쪽 부분 배열 정렬 (피벗: 8)

| 단계 | 배열 상태 | 비교 요소 | 이동 방향 |
| --- | --- | --- | --- |
| 초기 | 9, 8, 6, 7 | - | - |
| 비교 | 9 ↔ 6 | 9 > 8 → 6이 왼쪽 이동 | 6, 8, 9, 7 |
| 비교 | 9 ↔ 7 | 9 > 8 → 7이 왼쪽 이동 | 6, 7, 8, 9 |
| 피벗 정렬 후 | 6, 7, 8, 9 | - | - |

### 최종 정렬 완료

| 단계 | 배열 상태 |
| --- | --- |
| 정렬 완료 | 2, 3, 4, 5, 6, 7, 8, 9 |

위와 같이, 퀵 정렬은 **피벗 선택 → 분할(Partitioning) → 재귀 호출을 통한 정렬** 단계를 반복하며 정렬을 완성합니다. 실전에서도 적절한 피벗 전략을 활용하여 효율적인 정렬을 수행하는 것이 중요합니다.

# 벽 부수고 이동하기 문제 풀이

## 문제 설명

2차원 배열로 주어진 맵에서 `0`은 이동할 수 있는 곳을 나타내고, `1`은 이동할 수 없는 벽이 있는 곳을 나타냅니다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려고 하는데, 이때 **최단 경로**로 이동해야 합니다. 또한, 한 번만 벽을 부수고 지나갈 수 있습니다.

최단 경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하며, 시작하는 칸과 끝나는 칸도 포함해서 셉니다. 각 칸에서 이동할 수 있는 방향은 상하좌우입니다.

### 제약 사항

- 한 번 벽을 부수고 지나가는 것이 더 짧은 경로가 될 수 있습니다.
- 이동할 수 없는 벽을 부술 수 있는 기회는 단 한 번입니다.
- `N`과 `M`은 맵의 크기를 의미하며, 1 ≤ N, M ≤ 1000입니다.

## 문제 해결 전략

1. **BFS (너비 우선 탐색)**을 사용하여 최단 경로를 찾습니다.
2. 벽을 부수고 지나갈 수 있는 상태와 부수지 않고 지나가는 상태를 구분하여, **3차원 방문 배열**을 사용합니다.
    - 방문 배열의 `[r][c][0]`은 벽을 부수지 않은 상태에서 해당 좌표를 방문했음을 의미합니다.
    - 방문 배열의 `[r][c][1]`은 벽을 부순 상태에서 해당 좌표를 방문했음을 의미합니다.
3. 각 좌표를 탐색할 때 벽을 부수는 경우와 부수지 않는 경우를 따로 관리합니다.

## 알고리즘 설명

1. **BFS 탐색**:
    - BFS는 각 좌표에서 상하좌우로 이동하면서 최단 경로를 탐색합니다.
    - 시작점 `(0, 0)`에서 출발하여, 벽을 부수지 않은 상태에서 탐색을 시작합니다.
    - 각 좌표마다 **벽을 부술 수 있는 상태**와 **부수지 않은 상태**를 따로 기록하여 탐색을 진행합니다.

2. **방문 처리**:
    - 이미 방문한 좌표는 다시 탐색하지 않도록 합니다. 벽을 부수지 않고 방문한 상태와 벽을 부수고 방문한 상태를 분리하여 처리합니다.

3. **최단 경로 탐색**:
    - 목표 지점 `(N-1, M-1)`에 도달하면, 그때까지의 경로 길이를 반환합니다.
    - 도달하지 못하면 `-1`을 반환합니다.

## 큐(Queue)를 직접 구현한 이유

JavaScript에서는 **배열(Array)**의 **shift()** 연산이 시간 복잡도 `O(n)`을 가지므로, 큐의 첫 번째 요소를 삭제할 때 성능 문제가 발생할 수 있습니다. 특히 **BFS (너비 우선 탐색)**에서는 큐에서 요소를 자주 삽입(`enqueue`)하고 제거(`dequeue`)해야 하기 때문에, 성능이 중요한 문제입니다.

따라서 성능 최적화를 위해, **큐를 직접 구현**하여 큐의 앞뒤에서 효율적으로 요소를 삽입하고 삭제할 수 있도록 합니다. 직접 구현한 큐는 **객체(Object)**를 사용하여 **상수 시간 O(1)**에 삽입 및 삭제 연산을 처리합니다.

### 시간 복잡도 분석
- BFS를 사용한 탐색으로, 각 좌표를 최대 두 번(벽을 부순 경우와 부수지 않은 경우) 방문할 수 있습니다. 따라서 시간 복잡도는 O(N * M)입니다.

### 공간 복잡도 분석
- visited 배열은 벽을 부수지 않은 상태와 부순 상태를 저장하기 때문에 O(N * M * 2)의 공간을 사용합니다.
